{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "src/Hasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Hasher {\n    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256[20] c = [\n        0,\n        105459342437457812771135172323083229699880076558714389201963426671496941082218,\n        44701464856968139370917285707027820936722631087422041426223071261295627070036,\n        41130458804021533314412899450586326522500270054983374850973845129658305660915,\n        28034035305707963547093327110582394283920526326883215327933669381957202488237,\n        67835101927061504797267889999629546147998413041540252422300881129244644115080,\n        77038500041308678193056750316134029091500078767515237185085918316009128923853,\n        104544454093982446733027218848029782092179398179105058587091749747719757285036,\n        22185654124844698314055180464281947193548886457852406483524286412315521924078,\n        11843198404908081669891232877866372505664551940087258443425983951700839758573,\n        75730223139679823188252090137101366517592105358927914928435294176125136703785,\n        63037111269339665253951994986804650300724512054442194752074821492998493619346,\n        100222574878814648498017222491060355999208577101797160841662251588925373209270,\n        16506531590690913941192929825193131037149846497963759319950973398493215082721,\n        25870657958016487342382077423324595640085963189536902617468804520968505489214,\n        3776681458614062867704305576886405923644290248776498775782616919101874199765,\n        28467337724409730306364372414422354542968529509867349778522341896421740722671,\n        66613445942499043245107522483384164860482134785917043209657158812816523619396,\n        8730377214678666664395213446285196951160996012879518134438322009847352589864,\n        71182301344205212203724160442778867079219260050250374209369439265688715521804\n    ];\n\n    function MiMC5Feisel(uint256 iL, uint256 iR, uint256 k) public view returns (uint256, uint256) {\n        uint256 nRounds = 20;\n\n        uint256 lastL;\n        uint256 lastR;\n\n        lastL = iL;\n        lastR = iR;\n\n        uint256 base;\n        uint256 base2;\n        uint256 base4;\n        uint256 temp;\n\n        for (uint256 i; i < nRounds; i++) {\n            base = addmod(addmod(lastR, k, p), c[i], p);\n            base2 = mulmod(base, base, p);\n            base4 = mulmod(base2, base2, p);\n            temp = lastR;\n            lastR = addmod(lastL, mulmod(base, base4, p), p);\n            lastL = temp;\n        }\n\n        return (lastL, lastR);\n    }\n\n    function MiMC5Sponge(uint256[] memory elements, uint256 k) public view returns (uint256) {\n        uint256 lastR;\n        uint256 lastC;\n\n        uint256 length = elements.length;\n        for (uint256 i; i < length; i++) {\n            (lastR, lastC) = MiMC5Feisel(addmod(lastR, elements[i], p), lastC, k);\n        }\n\n        return lastR;\n    }\n}\n"
    },
    "src/Tornado.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Hasher} from \"./Hasher.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IVerifier {\n    function verifyProof(\n        uint256[2] calldata _pA,\n        uint256[2][2] calldata _pB,\n        uint256[2] calldata _pC,\n        uint256[3] calldata _pubSignals\n    ) external;\n}\n\ncontract Tornado is ReentrancyGuard {\n    error WrongAmountDeposited(uint256 amount);\n    error CommitmentAlreadyRegistered(uint256 commitment);\n    error MerkleTreeFull();\n    error IndexOutOfBound(uint256 index);\n    error InvalidRoot();\n    error NullifierAlreadyUsed();\n    error InvalidProof();\n    error PaymentFailed();\n\n    event Deposit(uint256 root, uint256[10] hashPairings, uint8[10] pairDirections);\n    event Withdrawal(address to, uint256 nullifierHash);\n\n    Hasher public hasher;\n    address public verifier;\n\n    uint8 public treeLevel = 10;\n    uint256 public denomination = 0.1 ether;\n    uint256 public nextLeafIndex;\n\n    mapping(uint256 root => bool isKnown) public knownRoots;\n    mapping(uint8 level => uint256 levelHash) public lastLevelHash;\n    mapping(uint256 nullifier => bool hasBeenUsed) public nullifiers;\n    mapping(uint256 commitment => bool isRegistered) public commitments;\n\n    constructor(address _hasher, address _verifier) {\n        hasher = Hasher(_hasher);\n        verifier = _verifier;\n    }\n\n    function deposit(uint256 _commitment) external payable nonReentrant {\n        if (msg.value != denomination) {\n            revert WrongAmountDeposited(msg.value);\n        }\n        if (commitments[_commitment]) {\n            revert CommitmentAlreadyRegistered(_commitment);\n        }\n        if (nextLeafIndex > 2 ** treeLevel - 1) {\n            revert MerkleTreeFull();\n        }\n\n        uint256 newRoot;\n        uint256[10] memory hashPairings;\n        uint8[10] memory hashDirections; // 0 means left, 1 means right\n\n        uint256 currentIndex = nextLeafIndex;\n        uint256 currentHash = _commitment;\n\n        uint256 right;\n        uint256 left;\n        uint256[] memory MiMC5SpongeInputs = new uint256[](2);\n\n        for (uint8 i; i < treeLevel; i++) {\n            lastLevelHash[treeLevel] = currentHash;\n\n            if (currentIndex % 2 == 0) {\n                left = currentHash;\n                right = levelDefaults(i);\n                hashPairings[i] = levelDefaults(i);\n                hashDirections[i] = 0;\n            } else {\n                left = lastLevelHash[i];\n                right = currentHash;\n                hashPairings[i] = lastLevelHash[i];\n                hashDirections[i] = 1;\n            }\n\n            MiMC5SpongeInputs[0] = left;\n            MiMC5SpongeInputs[1] = right;\n\n            (uint256 hashResult) = hasher.MiMC5Sponge(MiMC5SpongeInputs, _commitment);\n\n            currentHash = hashResult;\n            currentIndex /= 2;\n        }\n\n        newRoot = currentHash;\n        knownRoots[newRoot] = true;\n        ++nextLeafIndex;\n        commitments[_commitment] = true;\n\n        emit Deposit(newRoot, hashPairings, hashDirections);\n    }\n\n    function withdraw(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[2] memory input)\n        external\n        nonReentrant\n    {\n        uint256 root = input[0];\n        uint256 nullifierHash = input[1];\n\n        if (!knownRoots[root]) {\n            revert InvalidRoot();\n        }\n        if (nullifiers[nullifierHash]) {\n            revert NullifierAlreadyUsed();\n        }\n        (bool success,) = verifier.call(\n            abi.encodeWithSignature(\n                \"verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[3])\",\n                a,\n                b,\n                c,\n                [root, nullifierHash, uint256(uint160(msg.sender))]\n            )\n        );\n        if(!success){\n            revert InvalidProof();\n        }\n        nullifiers[nullifierHash] = true;\n        (bool paymentOk, ) = msg.sender.call{value: denomination}(\"\");\n        if(!paymentOk){\n            revert PaymentFailed();\n        }\n\n        emit Withdrawal(msg.sender, nullifierHash);\n    }\n\n    function levelDefaults(uint256 index) internal pure returns (uint256) {\n        if (index > 9) {\n            revert IndexOutOfBound(index);\n        }\n\n        uint256[10] memory hashes = [\n            11453634411542844787499634721323414931465088881580445903117236537484788828581,\n            21759559294542366315284509249586907808062322870962667765282157872669179426305,\n            2800814587524735286159569377379752927188029721286562875729267220991164399242,\n            87253568801316884066334864872212400487325631090541227847966176534645555967330,\n            16091454649916794623929336129931295998098934060451480326351876193731015714666,\n            110276519996832799046081358197168128650129019969002202844137231385581283223032,\n            24361892621379661372463289462581121875681948013554894918820988553066750189444,\n            3803846826699328777041246343939067304378981667725046445242884711909804349800,\n            1246292310160105430640667147666993977742994472446958122107028133142438347983,\n            60783858348513431507842163713811445103610436806650599349647377026990568035512\n        ];\n\n        return hashes[index];\n    }\n}\n"
    },
    "src/Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax = 1990491058042507724254531647052605187474668143610679805636247533142131809156;\n    uint256 constant alphay = 17477250898117459370570098708953425781081196849647504828348097720432779817798;\n    uint256 constant betax1 = 18379846640421875217892784056040387653832593361753158173421065252666656957372;\n    uint256 constant betax2 = 10632749047985076869668067614147501294688533024606653817127560325528233522161;\n    uint256 constant betay1 = 5933783442574464985157330861546146253189200943784866855958050185656606877150;\n    uint256 constant betay2 = 10894355898925596151150333935528223340672791319100498264155536969325794434553;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 21080986837172612094444362534432851052017489625175320705026885934702997613016;\n    uint256 constant deltax2 = 11291302162980152001275830085127813812748333428793104427971399711603833212687;\n    uint256 constant deltay1 = 9061154402828168705352157591804654649288025760538176786539560141554749361695;\n    uint256 constant deltay2 = 2627302175969897931811927687741030511979176199718031375541600144786611876632;\n\n    uint256 constant IC0x = 307739951028349522376628541915758938559098434068969938988824316323210405072;\n    uint256 constant IC0y = 9814790867621332089114334862248288947935100072968893375682188637449002688653;\n\n    uint256 constant IC1x = 6236269019540270289738012187427587886319799969000315251226603694303980314021;\n    uint256 constant IC1y = 9436322420098389537766917348729449340231580754534721619894505989208820826859;\n\n    uint256 constant IC2x = 10382308315157152530998522694935622247108648250500050006379319567591190545422;\n    uint256 constant IC2y = 11177231060708742743358324988553470547814400821948073313753773706989847295644;\n\n    uint256 constant IC3x = 3408663513345353973053132612265015137557556841684826865694471459344719427303;\n    uint256 constant IC3y = 10272416661617104036394590923859909187480648619637684251560066426368659564981;\n\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(\n        uint256[2] calldata _pA,\n        uint256[2][2] calldata _pB,\n        uint256[2] calldata _pC,\n        uint256[3] calldata _pubSignals\n    ) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n\n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n\n            checkField(calldataload(add(_pubSignals, 0)))\n\n            checkField(calldataload(add(_pubSignals, 32)))\n\n            checkField(calldataload(add(_pubSignals, 64)))\n\n            checkField(calldataload(add(_pubSignals, 96)))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}