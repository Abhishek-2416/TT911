{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "src/Hasher.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract Hasher {\n    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256[20] c = [\n        0,\n        105459342437457812771135172323083229699880076558714389201963426671496941082218,\n        44701464856968139370917285707027820936722631087422041426223071261295627070036,\n        41130458804021533314412899450586326522500270054983374850973845129658305660915,\n        28034035305707963547093327110582394283920526326883215327933669381957202488237,\n        67835101927061504797267889999629546147998413041540252422300881129244644115080,\n        77038500041308678193056750316134029091500078767515237185085918316009128923853,\n        104544454093982446733027218848029782092179398179105058587091749747719757285036,\n        22185654124844698314055180464281947193548886457852406483524286412315521924078,\n        11843198404908081669891232877866372505664551940087258443425983951700839758573,\n        75730223139679823188252090137101366517592105358927914928435294176125136703785,\n        63037111269339665253951994986804650300724512054442194752074821492998493619346,\n        100222574878814648498017222491060355999208577101797160841662251588925373209270,\n        16506531590690913941192929825193131037149846497963759319950973398493215082721,\n        25870657958016487342382077423324595640085963189536902617468804520968505489214,\n        3776681458614062867704305576886405923644290248776498775782616919101874199765,\n        28467337724409730306364372414422354542968529509867349778522341896421740722671,\n        66613445942499043245107522483384164860482134785917043209657158812816523619396,\n        8730377214678666664395213446285196951160996012879518134438322009847352589864,\n        71182301344205212203724160442778867079219260050250374209369439265688715521804\n    ];\n\n    function MiMC5Feisel(uint256 iL, uint256 iR, uint256 k) public view returns (uint256, uint256) {\n        uint256 nRounds = 20;\n\n        uint256 lastL;\n        uint256 lastR;\n\n        lastL = iL;\n        lastR = iR;\n\n        uint256 base;\n        uint256 base2;\n        uint256 base4;\n        uint256 temp;\n\n        for (uint256 i; i < nRounds; i++) {\n            base = addmod(addmod(lastR, k, p), c[i], p);\n            base2 = mulmod(base, base, p);\n            base4 = mulmod(base2, base2, p);\n            temp = lastR;\n            lastR = addmod(lastL, mulmod(base, base4, p), p);\n            lastL = temp;\n        }\n\n        return (lastL, lastR);\n    }\n\n    function MiMC5Sponge(uint256[] memory elements, uint256 k) public view returns (uint256) {\n        uint256 lastR;\n        uint256 lastC;\n\n        uint256 length = elements.length;\n        for (uint256 i; i < length; i++) {\n            (lastR, lastC) = MiMC5Feisel(addmod(lastR, elements[i], p), lastC, k);\n        }\n\n        return lastR;\n    }\n}\n"
    },
    "src/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IFlashLoanSimpleReceiver\n * @author Aave\n * @notice Defines the basic interface of a flashloan-receiver contract.\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\n */\ninterface IFlashLoanReceiver {\n  /**\n   * @notice Executes an operation after receiving the flash-borrowed asset\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\n   *      enough funds to repay and has approved the Pool to pull the total amount\n   * @param amount The amount of the flash-borrowed asset\n   * @param fee The fee of the flash-borrowed asset\n   * @param initiator The address of the flashloan initiator\n   * @return True if the execution of the operation succeeds, false otherwise\n   */\n  function executeOperation(\n    uint256 amount,\n    uint256 fee,\n    address initiator\n  ) external returns (bool);\n\n\n}"
    },
    "src/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity >=0.4.0;\n\ninterface IWETH9 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function balanceOf(address) external view returns (uint);\n\n    function allowance(address, address) external view returns (uint);\n\n    receive() external payable;\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad)\n    external\n    returns (bool);\n}"
    },
    "src/Tornado.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Hasher} from \"./Hasher.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./IWETH9.sol\";\nimport \"./IFlashLoanReceiver.sol\";\n\n\ninterface IVerifier {\n    function verifyProof(\n        uint256[2] calldata _pA,\n        uint256[2][2] calldata _pB,\n        uint256[2] calldata _pC,\n        uint256[3] calldata _pubSignals\n    ) external;\n}\n\ncontract Tornado is ReentrancyGuard {\n    error WrongAmountDeposited(uint256 amount);\n    error CommitmentAlreadyRegistered(uint256 commitment);\n    error MerkleTreeFull();\n    error IndexOutOfBound(uint256 index);\n    error InvalidRoot();\n    error NullifierAlreadyUsed();\n    error InvalidProof();\n    error PaymentFailed();\n\n    event Deposit(uint256 root, uint256[10] hashPairings, uint8[10] pairDirections);\n    event Withdrawal(address to, uint256 nullifierHash);\n\n    Hasher public hasher;\n    address public verifier;\n\n    uint8 public treeLevel = 10;\n    uint256 public denomination = 0.001 ether;\n    uint256 public nextLeafIndex;\n    address payable weth;\n    uint256 immutable loanPercent;\n    uint256 internal constant PERCENTAGE_FACTOR = 1e4;\n    uint256 feeCollected;\n    address payable relayer;\n\n    // Half percentage factor (50.00%)\n    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;\n\n    event FlashLoanEvent(\n        address indexed target,\n        address initiator,\n        uint256 amount,\n        uint256 premium\n    );\n\n    mapping(uint256 root => bool isKnown) public knownRoots;\n    mapping(uint8 level => uint256 levelHash) public lastLevelHash;\n    mapping(uint256 nullifier => bool hasBeenUsed) public nullifiers;\n    mapping(uint256 commitment => bool isRegistered) public commitments;\n\n    constructor(address _hasher, address _verifier,address payable _weth, uint256 _loanPercent, address payable _relayer){\n        hasher = Hasher(_hasher);\n        verifier = _verifier;\n        weth = _weth;\n        relayer = _relayer;\n        loanPercent = _loanPercent;\n    }\n\n    function deposit(uint256 _commitment) external payable nonReentrant {\n        require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\");\n\n        if (commitments[_commitment]) {\n            revert CommitmentAlreadyRegistered(_commitment);\n        }\n        if (nextLeafIndex > 2 ** treeLevel - 1) {\n            revert MerkleTreeFull();\n        }\n\n        uint256 newRoot;\n        uint256[10] memory hashPairings;\n        uint8[10] memory hashDirections; // 0 means left, 1 means right\n\n        uint256 currentIndex = nextLeafIndex;\n        uint256 currentHash = _commitment;\n\n        uint256 right;\n        uint256 left;\n        uint256[] memory MiMC5SpongeInputs = new uint256[](2);\n\n        for (uint8 i; i < treeLevel; i++) {\n            lastLevelHash[treeLevel] = currentHash;\n\n            if (currentIndex % 2 == 0) {\n                left = currentHash;\n                right = levelDefaults(i);\n                hashPairings[i] = levelDefaults(i);\n                hashDirections[i] = 0;\n            } else {\n                left = lastLevelHash[i];\n                right = currentHash;\n                hashPairings[i] = lastLevelHash[i];\n                hashDirections[i] = 1;\n            }\n\n            MiMC5SpongeInputs[0] = left;\n            MiMC5SpongeInputs[1] = right;\n\n            (uint256 hashResult) = hasher.MiMC5Sponge(MiMC5SpongeInputs, _commitment);\n\n            currentHash = hashResult;\n            currentIndex /= 2;\n        }\n\n        newRoot = currentHash;\n        knownRoots[newRoot] = true;\n        ++nextLeafIndex;\n        commitments[_commitment] = true;\n\n        bool ok = IWETH9(weth).transferFrom(msg.sender, address(this), denomination);\n\n        if(!ok){\n            revert PaymentFailed();\n        }\n\n        emit Deposit(newRoot, hashPairings, hashDirections);\n    }\n\n    function withdraw(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[2] memory input)\n        external\n        nonReentrant\n    {\n        uint256 root = input[0];\n        uint256 nullifierHash = input[1];\n\n        if (!knownRoots[root]) {\n            revert InvalidRoot();\n        }\n        if (nullifiers[nullifierHash]) {\n            revert NullifierAlreadyUsed();\n        }\n        (bool success,) = verifier.call(\n            abi.encodeWithSignature(\n                \"verifyProof(uint256[2],uint256[2][2],uint256[2],uint256[3])\",\n                a,\n                b,\n                c,\n                [root, nullifierHash, uint256(uint160(msg.sender))]\n            )\n        );\n        if(!success){\n            revert InvalidProof();\n        }\n        nullifiers[nullifierHash] = true;\n        bool paymentOk = IWETH9(weth).transfer(msg.sender, denomination);\n        if(!paymentOk){\n            revert PaymentFailed();\n        }\n\n        emit Withdrawal(msg.sender, nullifierHash);\n    }\n\n    function levelDefaults(uint256 index) internal pure returns (uint256) {\n        if (index > 9) {\n            revert IndexOutOfBound(index);\n        }\n\n        uint256[10] memory hashes = [\n            11453634411542844787499634721323414931465088881580445903117236537484788828581,\n            21759559294542366315284509249586907808062322870962667765282157872669179426305,\n            2800814587524735286159569377379752927188029721286562875729267220991164399242,\n            87253568801316884066334864872212400487325631090541227847966176534645555967330,\n            16091454649916794623929336129931295998098934060451480326351876193731015714666,\n            110276519996832799046081358197168128650129019969002202844137231385581283223032,\n            24361892621379661372463289462581121875681948013554894918820988553066750189444,\n            3803846826699328777041246343939067304378981667725046445242884711909804349800,\n            1246292310160105430640667147666993977742994472446958122107028133142438347983,\n            60783858348513431507842163713811445103610436806650599349647377026990568035512\n        ];\n\n        return hashes[index];\n    }\n\n    function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {\n    // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage\n    assembly {\n      if iszero(\n        or(\n          iszero(percentage),\n          iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage)))\n        )\n      ) {\n        revert(0, 0)\n      }\n\n      result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)\n    }\n  }\n\n    function executeFlashLoanSimple(\n        address receiverAddress,\n        uint256 amount\n    ) external {\n\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(receiverAddress);\n        uint256 fee = percentMul(amount, loanPercent);\n        IWETH9(weth).transfer(receiverAddress, amount);\n\n        require(\n        receiver.executeOperation(\n            amount,\n            fee,\n            msg.sender\n        ),\n        \"INVALID_FLASHLOAN_EXECUTOR_RETURN\"\n        );\n\n        uint256 amountPlusPremium = amount + fee;\n\n        IWETH9(weth).transferFrom(\n            receiverAddress,\n            address(this),\n            amountPlusPremium\n        );\n\n        IWETH9(weth).withdraw(fee);\n        relayer.transfer(fee);\n        \n        emit FlashLoanEvent(\n            receiverAddress,\n            msg.sender,\n            amount,\n            fee\n        );\n    }\n}"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}